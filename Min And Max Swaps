You are given two arrays ğ‘ and ğ‘ of ğ‘› positive integers each. You can apply the following operation to them any number of times:

Select an index ğ‘– (1â‰¤ğ‘–â‰¤ğ‘›) and swap ğ‘ğ‘– with ğ‘ğ‘– (i. e. ğ‘ğ‘– becomes ğ‘ğ‘– and vice versa).
Find the minimum possible value of max(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›)â‹…max(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›) you can get after applying such operation any number of times (possibly zero).

Input
The input consists of multiple test cases. The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤100) â€” the number of test cases. Description of the test cases follows.

The first line of each test case contains an integer ğ‘› (1â‰¤ğ‘›â‰¤100) â€” the length of the arrays.

The second line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤10000) where ğ‘ğ‘– is the ğ‘–-th element of the array ğ‘.

The third line of each test case contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (1â‰¤ğ‘ğ‘–â‰¤10000) where ğ‘ğ‘– is the ğ‘–-th element of the array ğ‘.

Output
For each test case, print a single integer, the minimum possible value of max(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›)â‹…max(ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›) you can get after applying such operation any number of times.

Example
inputCopy
3
6
1 2 6 5 1 2
3 4 3 2 2 5
3
3 3 3
3 3 3
2
1 2
2 1
outputCopy
18
9
2

Codes Are:-
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {   int n;
    cin>>n;
        int p[n],v[n];
        for(auto i=0;i<n;i++)
        {
            cin>>v[i];
        }
        for(auto i=0;i<n;i++)
        {
            cin>>p[i];
        }
        
        for(auto i=0;i<n;i++)
        {
            if(v[i]<=p[i])
            {
                swap(v[i],p[i]);
            }
            
        }
        
        cout<< *max_element(v,v+n)*(*max_element(p,p+n))<<endl;
    }
}
