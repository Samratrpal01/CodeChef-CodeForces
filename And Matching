You are given a set of ğ‘› (ğ‘› is always a power of 2) elements containing all integers 0,1,2,â€¦,ğ‘›âˆ’1 exactly once.

Find ğ‘›2 pairs of elements such that:

Each element in the set is in exactly one pair.
The sum over all pairs of the bitwise AND of its elements must be exactly equal to ğ‘˜. Formally, if ğ‘ğ‘– and ğ‘ğ‘– are the elements of the ğ‘–-th pair, then the following must hold:
âˆ‘ğ‘–=1ğ‘›/2ğ‘ğ‘–&ğ‘ğ‘–=ğ‘˜,
where & denotes the bitwise AND operation.
If there are many solutions, print any of them, if there is no solution, print âˆ’1 instead.

Input
The input consists of multiple test cases. The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤400) â€” the number of test cases. Description of the test cases follows.

Each test case consists of a single line with two integers ğ‘› and ğ‘˜ (4â‰¤ğ‘›â‰¤216, ğ‘› is a power of 2, 0â‰¤ğ‘˜â‰¤ğ‘›âˆ’1).

The sum of ğ‘› over all test cases does not exceed 216. All test cases in each individual input will be pairwise different.

Output
For each test case, if there is no solution, print a single line with the integer âˆ’1.

Otherwise, print ğ‘›2 lines, the ğ‘–-th of them must contain ğ‘ğ‘– and ğ‘ğ‘–, the elements in the ğ‘–-th pair.

If there are many solutions, print any of them. Print the pairs and the elements in the pairs in any order.

Example
inputCopy
4
4 0
4 1
4 2
4 3
outputCopy
0 3
1 2
0 2
1 3
0 1
2 3
-1
Note
In the first test, (0&3)+(1&2)=0.

In the second test, (0&2)+(1&3)=1.

In the third test, (0&1)+(2&3)=2.

In the fourth test, there is no solution.

Codes Are:-
#include<bits/stdc++.h>
using namespace std;
int a[100005];
 
int main () {
	int T;
	scanf("%d", &T);
	while (T--) {
		int n, k;
		scanf("%d%d", &n, &k);
		if (n == 4 && k == 3) {
			puts("-1");
			continue;
		}
		for (int i = 0; i < n; i++) a[i] = i;
		if (k == n-1) {
			swap(a[0], a[n-2]);
			swap(a[1], a[n-4]);
		}else {
			swap(a[0], a[k]);
		}
		for (int i = 0; i < n/2; i++) printf("%d %d\n", a[i], a[n-i-1]);
	}
}
