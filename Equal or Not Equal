Description Are:-
You had ğ‘› positive integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› arranged in a circle. For each pair of neighboring numbers (ğ‘1 and ğ‘2, ğ‘2 and ğ‘3, ..., ğ‘ğ‘›âˆ’1 and ğ‘ğ‘›, and ğ‘ğ‘› and ğ‘1), you wrote down: are the numbers in the pair equal or not.

Unfortunately, you've lost a piece of paper with the array ğ‘. Moreover, you are afraid that even information about equality of neighboring elements may be inconsistent. So, you are wondering: is there any array ğ‘ which is consistent with information you have about equality or non-equality of corresponding pairs?

Input
The first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤1000) â€” the number of test cases. Next ğ‘¡ cases follow.

The first and only line of each test case contains a non-empty string ğ‘  consisting of characters E and/or N. The length of ğ‘  is equal to the size of array ğ‘› and 2â‰¤ğ‘›â‰¤50. For each ğ‘– from 1 to ğ‘›:

if ğ‘ ğ‘–= E then ğ‘ğ‘– is equal to ğ‘ğ‘–+1 (ğ‘ğ‘›=ğ‘1 for ğ‘–=ğ‘›);
if ğ‘ ğ‘–= N then ğ‘ğ‘– is not equal to ğ‘ğ‘–+1 (ğ‘ğ‘›â‰ ğ‘1 for ğ‘–=ğ‘›).
Output
For each test case, print YES if it's possible to choose array ğ‘ that are consistent with information from ğ‘  you know. Otherwise, print NO.

It can be proved, that if there exists some array ğ‘, then there exists an array ğ‘ of positive integers with values less or equal to 109

Codes Are:-
#include<bits/stdc++.h>
using namespace std;
void solve()
{
    string s;
  cin>>s;
  int n=s.size();
  
  int e=0,ne=0;
 
  for(int i=0;i<n;i++)
  {
    if(s[i]=='E')
      e++;
    else
      ne++;
  }
 
  if(ne==1 && e==n-1)
  {
    cout<<"NO"<<"\n";
    return;
  }
  if(s=="EN" || s=="NE")
    cout<<"NO"<<"\n";
  else
    cout<<"YES"<<"\n";
}
int main()
{
    int t = 1;
    cin >> t;
    int t1=1;
    while(t--)
    {
        solve();
        t1++;
    }
 
    return 0;
}
